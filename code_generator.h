/************************************************************************
 * 
 * Compiler implementation for imperative programming language IFJ18
 * 
 * Autors:
 * Sasák Tomáš - xsasak01
 * Venkrbec Tomáš - xvenkr01
 * Krajči Martin - xkrajc21
 * Dižová Natália - xdizov00 
 * 
 ***********************************************************************/
#include "scanner.h"

// This constant is numerical difference between builtin functions with return value moved or not
#define NOCALL_CALL_DIFFERENCE 22
// Macros for instruction inside instruction list
#define DEFVAR 228
// User's functions
#define FUN_DEF 200
#define FUN_END 201
#define FUN_CALL 202 // function return is going to be saved
#define NOFUN_CALL 216 // function return value is not going to be saved
// If calls
#define IF_CALL 203
#define ELSE_CALL 204
#define IF_END 205
#define IF_COND_END 260
// While calls
#define WHILE_CALL 206
#define WHILE_END 207
#define WHILE_COND_END 238
// Built-in functions
#define INPUTS_CALL 208
#define INPUTI_CALL 209
#define INPUTF_CALL 210
#define PRINT_CALL 211
#define LENGTH_CALL 212
#define SUBSTR_CALL 213
#define ORD_CALL 214
#define CHR_CALL 215
#define NOINPUTS_CALL 230
#define NOINPUTI_CALL 231
#define NOINPUTF_CALL 232
#define NOPRINT_CALL 233
#define NOLENGTH_CALL 234
#define NOSUBSTR_CALL 235
#define NOORD_CALL 236
#define NOCHR_CALL 237
#define CONCAT_CALL 253
#define CONCAT_END 254
// Operators
#define ADD 217 // '+'
#define SUB 218 // '-'
#define MUL 219 // '*'
#define DIV 220 // '/'
#define MOVE 221 // '='
#define EQ  222 // '=='
#define LT  223 // '<'
#define LE  224 // '<='
#define GT  225 // '>'
#define GE  226 // '>='
#define NE  227 // '!='
#define CONCAT 252 // string + string
// Data stack instructions
#define EXPRESSION_CALL 255
#define EXPRESSION_END 256
#define ADDS 241
#define SUBS 242
#define MULS 243
#define DIVS 244
#define LTS 246
#define GTS 247
#define EQS 248
#define PUSHS 249
#define POPS 250
#define NOTS 251
// Empty instruction
#define NOP 299

typedef struct tokenList tTList;
typedef struct instructionList tIList;
typedef struct instructionNode tInstr;
typedef struct pointerNode tPtr;
typedef struct pointerList tPList;


/**
 * Structure used for deallocating strings which are shared for multiple tokens to prevent double free (SEGABRT).
 * Structure works as ADS single-linked list.
 */
typedef struct pointerList
{
    tPtr *head; //< Pointer to the head of the single-linked list.
    tPtr *active; //< Pointer to the last member of the list, which speed's up adding new member to the list.
}pointerList;

/**
 * Structure which signifies one member(node) of single-linked list with strings to prevent double free.
 * @see tTList
 */
typedef struct pointerNode
{
    string freed; //< String which is going to get free.
    tPtr *next; //< Pointer to the next member(node).
}pointerNode;

/**
 * Structure ADS single-linked list which contains parameters saved as tokens of ONE instruction in instruction list.
 * Example: ord(s, i) - token s and token i is in this list.
 * @see tIList
 */
typedef struct tokenList
{
    tToken param; //< Token which signifies one parameter of instruction.
    tTList *next; //< Pointer to the next parameter. (single-linked list)
}tokenList;

/**
 * Structure which signifies one instruction with parameters inside instruction list (single-linked list ADS).
 * @see tIList
 */
typedef struct instructionNode
{
    int instr; //< Macro of one instruction generated by parser, macros are in code_generator.h.
    tTList *params; //< Pointer to the parameters of instruction (single-linked list).
    tInstr *next; //< Pointer to the next instruction. 
}instructionNode;

/**
 * Structures which is main structure of the code generator, this ADS (single-linked list) signifies inside mid-code of compiler which is generated by parser, after parsing, this list is submited for code generator
 * to generate final compiled code. 
 */
typedef struct instructionList 
{
    tInstr *head; //< First generated instruction, head of the list.
    tInstr *active; //< Latest generated instruction, to speed appending of list.
}instructionList;

/**
 * This global variable is pointer to the final mid-code, used by code generator.
 */
tIList *ilist;

tToken choose_return(tInstr *instruction);
void init_plist(tPList *plist);
void init_ilist(tIList *instrs);
void insert_instr(tIList *instrs, int instr);
void insert_param(tIList *instrs, tToken param);
void insert_ptr(tPList *plist, string freed);
bool search_ptr(tPList *ptr, string freed);
void free_ilist(tIList *instrs);
void free_plist(tPList *plist);
void generate_code();
void generate_instruction(FILE *f, tInstr *instruction);
int generate_if(FILE *f, tInstr *instruction, bool scoped, int uniqueIf);
int generate_while(FILE *f, tInstr *instruction, bool scoped, int uniqueWhile);